// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: artist.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const createArtist = `-- name: CreateArtist :one
INSERT INTO artist (id, artist_title, artist_subtitle, bio, avatar_id)
VALUES ($1, $2, $3, $4, $5) RETURNING id, artist_title, artist_subtitle, bio, avatar_id, user_id, created_at, updated_at, version
`

type CreateArtistParams struct {
	ID             uuid.UUID  `json:"id"`
	ArtistTitle    string     `json:"artist_title"`
	ArtistSubtitle *string    `json:"artist_subtitle"`
	Bio            *string    `json:"bio"`
	AvatarID       *uuid.UUID `json:"avatar_id"`
}

func (q *Queries) CreateArtist(ctx context.Context, arg CreateArtistParams) (Artist, error) {
	row := q.db.QueryRow(ctx, createArtist,
		arg.ID,
		arg.ArtistTitle,
		arg.ArtistSubtitle,
		arg.Bio,
		arg.AvatarID,
	)
	var i Artist
	err := row.Scan(
		&i.ID,
		&i.ArtistTitle,
		&i.ArtistSubtitle,
		&i.Bio,
		&i.AvatarID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const deleteArtist = `-- name: DeleteArtist :exec
DELETE FROM artist
WHERE id = $1
`

func (q *Queries) DeleteArtist(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteArtist, id)
	return err
}

const getAllArtists = `-- name: GetAllArtists :many
SELECT artist.id, artist.artist_title, artist.artist_subtitle, artist.bio, artist.avatar_id, artist.user_id, artist.created_at, artist.updated_at, artist.version FROM artist
ORDER BY artist.artist_title ASC
`

type GetAllArtistsRow struct {
	Artist Artist `json:"artist"`
}

func (q *Queries) GetAllArtists(ctx context.Context) ([]GetAllArtistsRow, error) {
	rows, err := q.db.Query(ctx, getAllArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllArtistsRow{}
	for rows.Next() {
		var i GetAllArtistsRow
		if err := rows.Scan(
			&i.Artist.ID,
			&i.Artist.ArtistTitle,
			&i.Artist.ArtistSubtitle,
			&i.Artist.Bio,
			&i.Artist.AvatarID,
			&i.Artist.UserID,
			&i.Artist.CreatedAt,
			&i.Artist.UpdatedAt,
			&i.Artist.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtistByID = `-- name: GetArtistByID :one
SELECT artist.id, artist.artist_title, artist.artist_subtitle, artist.bio, artist.avatar_id, artist.user_id, artist.created_at, artist.updated_at, artist.version FROM artist
WHERE artist.id = $1
`

type GetArtistByIDRow struct {
	Artist Artist `json:"artist"`
}

func (q *Queries) GetArtistByID(ctx context.Context, id uuid.UUID) (GetArtistByIDRow, error) {
	row := q.db.QueryRow(ctx, getArtistByID, id)
	var i GetArtistByIDRow
	err := row.Scan(
		&i.Artist.ID,
		&i.Artist.ArtistTitle,
		&i.Artist.ArtistSubtitle,
		&i.Artist.Bio,
		&i.Artist.AvatarID,
		&i.Artist.UserID,
		&i.Artist.CreatedAt,
		&i.Artist.UpdatedAt,
		&i.Artist.Version,
	)
	return i, err
}

const getArtistsByTitle = `-- name: GetArtistsByTitle :many
SELECT artist.id, artist.artist_title, artist.artist_subtitle, artist.bio, artist.avatar_id, artist.user_id, artist.created_at, artist.updated_at, artist.version FROM artist
WHERE similarity(artist.artist_title, $1) > $2
ORDER BY similarity(artist.artist_title, $1) DESC
`

type GetArtistsByTitleParams struct {
	Title         string  `json:"title"`
	MinSimilarity float32 `json:"min_similarity"`
}

type GetArtistsByTitleRow struct {
	Artist Artist `json:"artist"`
}

func (q *Queries) GetArtistsByTitle(ctx context.Context, arg GetArtistsByTitleParams) ([]GetArtistsByTitleRow, error) {
	rows, err := q.db.Query(ctx, getArtistsByTitle, arg.Title, arg.MinSimilarity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetArtistsByTitleRow{}
	for rows.Next() {
		var i GetArtistsByTitleRow
		if err := rows.Scan(
			&i.Artist.ID,
			&i.Artist.ArtistTitle,
			&i.Artist.ArtistSubtitle,
			&i.Artist.Bio,
			&i.Artist.AvatarID,
			&i.Artist.UserID,
			&i.Artist.CreatedAt,
			&i.Artist.UpdatedAt,
			&i.Artist.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArtist = `-- name: UpdateArtist :one
UPDATE artist
SET artist_title = $2, artist_subtitle = $3, bio = $4, avatar_id = $5
WHERE id = $1 RETURNING id, artist_title, artist_subtitle, bio, avatar_id, user_id, created_at, updated_at, version
`

type UpdateArtistParams struct {
	ID             uuid.UUID  `json:"id"`
	ArtistTitle    string     `json:"artist_title"`
	ArtistSubtitle *string    `json:"artist_subtitle"`
	Bio            *string    `json:"bio"`
	AvatarID       *uuid.UUID `json:"avatar_id"`
}

func (q *Queries) UpdateArtist(ctx context.Context, arg UpdateArtistParams) (Artist, error) {
	row := q.db.QueryRow(ctx, updateArtist,
		arg.ID,
		arg.ArtistTitle,
		arg.ArtistSubtitle,
		arg.Bio,
		arg.AvatarID,
	)
	var i Artist
	err := row.Scan(
		&i.ID,
		&i.ArtistTitle,
		&i.ArtistSubtitle,
		&i.Bio,
		&i.AvatarID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}
