// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: event.sql

package models

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addArtistToEvent = `-- name: AddArtistToEvent :exec
INSERT INTO timeslot (id, event_id, artist_id, artist_name_override, sort_key)
VALUES ($1, $2, $3, $4, $5)
`

type AddArtistToEventParams struct {
	ID                 uuid.UUID `json:"id"`
	EventID            uuid.UUID `json:"event_id"`
	ArtistID           uuid.UUID `json:"artist_id"`
	ArtistNameOverride *string   `json:"artist_name_override"`
	SortKey            string    `json:"sort_key"`
}

func (q *Queries) AddArtistToEvent(ctx context.Context, arg AddArtistToEventParams) error {
	_, err := q.db.Exec(ctx, addArtistToEvent,
		arg.ID,
		arg.EventID,
		arg.ArtistID,
		arg.ArtistNameOverride,
		arg.SortKey,
	)
	return err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO event (id, event_type, start_time, end_time)
VALUES ($1, $2, $3, $4) RETURNING id, event_type, start_time, end_time, created_at, updated_at, version
`

type CreateEventParams struct {
	ID        uuid.UUID `json:"id"`
	EventType string    `json:"event_type"`
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.ID,
		arg.EventType,
		arg.StartTime,
		arg.EndTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const createTimeslotMarker = `-- name: CreateTimeslotMarker :one
INSERT INTO timeslot_marker (id, event_id, marker_type, marker_value, timeslot_index)
VALUES ($1, $2, $3, $4, $5) RETURNING id, event_id, timeslot_index, marker_type, marker_value
`

type CreateTimeslotMarkerParams struct {
	ID            uuid.UUID `json:"id"`
	EventID       uuid.UUID `json:"event_id"`
	MarkerType    string    `json:"marker_type"`
	MarkerValue   string    `json:"marker_value"`
	TimeslotIndex int32     `json:"timeslot_index"`
}

func (q *Queries) CreateTimeslotMarker(ctx context.Context, arg CreateTimeslotMarkerParams) (TimeslotMarker, error) {
	row := q.db.QueryRow(ctx, createTimeslotMarker,
		arg.ID,
		arg.EventID,
		arg.MarkerType,
		arg.MarkerValue,
		arg.TimeslotIndex,
	)
	var i TimeslotMarker
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.TimeslotIndex,
		&i.MarkerType,
		&i.MarkerValue,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM event
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deleteTimeslotMarker = `-- name: DeleteTimeslotMarker :exec
DELETE FROM timeslot_marker
WHERE id = $1
`

func (q *Queries) DeleteTimeslotMarker(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTimeslotMarker, id)
	return err
}

const getAllEvents = `-- name: GetAllEvents :many
SELECT event.id, event.event_type, event.start_time, event.end_time, event.created_at, event.updated_at, event.version, COALESCE(json_agg(timeslot_marker.*) FILTER (WHERE timeslot_marker.event_id IS NOT NULL), '[]')::json as markers FROM event
LEFT JOIN timeslot_marker ON event.id = timeslot_marker.event_id
GROUP BY event.id
ORDER BY event.start_time ASC
`

type GetAllEventsRow struct {
	Event   Event  `json:"event"`
	Markers []byte `json:"markers"`
}

func (q *Queries) GetAllEvents(ctx context.Context) ([]GetAllEventsRow, error) {
	rows, err := q.db.Query(ctx, getAllEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllEventsRow{}
	for rows.Next() {
		var i GetAllEventsRow
		if err := rows.Scan(
			&i.Event.ID,
			&i.Event.EventType,
			&i.Event.StartTime,
			&i.Event.EndTime,
			&i.Event.CreatedAt,
			&i.Event.UpdatedAt,
			&i.Event.Version,
			&i.Markers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT event.id, event.event_type, event.start_time, event.end_time, event.created_at, event.updated_at, event.version, COALESCE(json_agg(timeslot_marker.*) FILTER (WHERE timeslot_marker.event_id IS NOT NULL), '[]')::json as markers FROM event
LEFT JOIN timeslot_marker ON event.id = timeslot_marker.event_id
WHERE event.id = $1
GROUP BY event.id
`

type GetEventByIDRow struct {
	Event   Event  `json:"event"`
	Markers []byte `json:"markers"`
}

func (q *Queries) GetEventByID(ctx context.Context, id uuid.UUID) (GetEventByIDRow, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i GetEventByIDRow
	err := row.Scan(
		&i.Event.ID,
		&i.Event.EventType,
		&i.Event.StartTime,
		&i.Event.EndTime,
		&i.Event.CreatedAt,
		&i.Event.UpdatedAt,
		&i.Event.Version,
		&i.Markers,
	)
	return i, err
}

const removeArtistFromEvent = `-- name: RemoveArtistFromEvent :exec
DELETE FROM timeslot
WHERE event_id = $1 AND artist_id = $2
`

type RemoveArtistFromEventParams struct {
	EventID  uuid.UUID `json:"event_id"`
	ArtistID uuid.UUID `json:"artist_id"`
}

func (q *Queries) RemoveArtistFromEvent(ctx context.Context, arg RemoveArtistFromEventParams) error {
	_, err := q.db.Exec(ctx, removeArtistFromEvent, arg.EventID, arg.ArtistID)
	return err
}

const timeSlotsByEventID = `-- name: TimeSlotsByEventID :many
SELECT timeslot.id, timeslot.event_id, timeslot.artist_id, timeslot.artist_name_override, timeslot.song_count, timeslot.sort_key, timeslot.created_at, timeslot.updated_at, timeslot.version, artist.id, artist.artist_title, artist.artist_subtitle, artist.bio, artist.avatar_id, artist.user_id, artist.created_at, artist.updated_at, artist.version FROM timeslot
JOIN artist ON timeslot.artist_id = artist.id
WHERE timeslot.event_id = $1
ORDER BY timeslot.sort_key ASC
`

type TimeSlotsByEventIDRow struct {
	Timeslot Timeslot `json:"timeslot"`
	Artist   Artist   `json:"artist"`
}

func (q *Queries) TimeSlotsByEventID(ctx context.Context, eventID uuid.UUID) ([]TimeSlotsByEventIDRow, error) {
	rows, err := q.db.Query(ctx, timeSlotsByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimeSlotsByEventIDRow{}
	for rows.Next() {
		var i TimeSlotsByEventIDRow
		if err := rows.Scan(
			&i.Timeslot.ID,
			&i.Timeslot.EventID,
			&i.Timeslot.ArtistID,
			&i.Timeslot.ArtistNameOverride,
			&i.Timeslot.SongCount,
			&i.Timeslot.SortKey,
			&i.Timeslot.CreatedAt,
			&i.Timeslot.UpdatedAt,
			&i.Timeslot.Version,
			&i.Artist.ID,
			&i.Artist.ArtistTitle,
			&i.Artist.ArtistSubtitle,
			&i.Artist.Bio,
			&i.Artist.AvatarID,
			&i.Artist.UserID,
			&i.Artist.CreatedAt,
			&i.Artist.UpdatedAt,
			&i.Artist.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE event
SET event_type = $1, start_time = $2, end_time = $3
WHERE id = $4 RETURNING id, event_type, start_time, end_time, created_at, updated_at, version
`

type UpdateEventParams struct {
	EventType string    `json:"event_type"`
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.EventType,
		arg.StartTime,
		arg.EndTime,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const updateTimeSlot = `-- name: UpdateTimeSlot :many
UPDATE timeslot
SET artist_name_override = $1, sort_key = $2, song_count = $3
WHERE id = $4 RETURNING id, event_id, artist_id, artist_name_override, song_count, sort_key, created_at, updated_at, version
`

type UpdateTimeSlotParams struct {
	ArtistNameOverride *string   `json:"artist_name_override"`
	SortKey            string    `json:"sort_key"`
	SongCount          int32     `json:"song_count"`
	ID                 uuid.UUID `json:"id"`
}

func (q *Queries) UpdateTimeSlot(ctx context.Context, arg UpdateTimeSlotParams) ([]Timeslot, error) {
	rows, err := q.db.Query(ctx, updateTimeSlot,
		arg.ArtistNameOverride,
		arg.SortKey,
		arg.SongCount,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Timeslot{}
	for rows.Next() {
		var i Timeslot
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ArtistID,
			&i.ArtistNameOverride,
			&i.SongCount,
			&i.SortKey,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTimeslotMarker = `-- name: UpdateTimeslotMarker :one
UPDATE timeslot_marker
SET marker_type = $1, marker_value = $2, timeslot_index = $3
WHERE id = $4 RETURNING id, event_id, timeslot_index, marker_type, marker_value
`

type UpdateTimeslotMarkerParams struct {
	MarkerType    string    `json:"marker_type"`
	MarkerValue   string    `json:"marker_value"`
	TimeslotIndex int32     `json:"timeslot_index"`
	ID            uuid.UUID `json:"id"`
}

func (q *Queries) UpdateTimeslotMarker(ctx context.Context, arg UpdateTimeslotMarkerParams) (TimeslotMarker, error) {
	row := q.db.QueryRow(ctx, updateTimeslotMarker,
		arg.MarkerType,
		arg.MarkerValue,
		arg.TimeslotIndex,
		arg.ID,
	)
	var i TimeslotMarker
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.TimeslotIndex,
		&i.MarkerType,
		&i.MarkerValue,
	)
	return i, err
}
